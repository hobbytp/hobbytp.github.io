<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<div id="chat-launcher" 
     class="chat-launcher" 
     role="button" 
     tabindex="0"
     aria-label="打开聊天窗口"
     onclick="toggleChat()"
     onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggleChat();}">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
    </svg>
</div>

<div id="chat-window" class="chat-window hidden">
    <div class="chat-header">
        <div class="chat-avatar">
            <img src="/images/profile.jpg" alt="AI Assistant" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMjEgMTVhMiAyIDAgMCAxLTIgMkg3bC00IDRWNWEyIDIgMCAwIDEgMi0yaDE0YTIgMiAwIDAgMSAyIDJ6Ij48L3BhdGg+PC9zdmc+'">
        </div>
        <div class="chat-title">
            <h3>数字分身</h3>
            <span class="status-dot"></span>
        </div>
        <button class="close-btn" onclick="toggleChat()" aria-label="关闭聊天窗口">&times;</button>
    </div>
    
    <div id="chat-messages" class="chat-messages">
        <div class="message assistant">
            <div class="message-content">
                你好！我是博主的 AI 数字分身。我阅读了所有博客文章，可以回答关于文章内容的问题。请问有什么可以帮你的吗？
            </div>
        </div>
    </div>
    
    <div class="chat-input-area">
        <textarea id="chat-input" placeholder="输入问题..." rows="1" onkeydown="handleKeyPress(event)"></textarea>
        <button id="send-btn" onclick="sendMessage()" aria-label="发送消息">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        </button>
    </div>
</div>

<script>
    let chatHistory = [];
    const MAX_HISTORY = 6; // 保留最近6条消息（3轮）

    function toggleChat() {
        const chatWindow = document.getElementById('chat-window');
        const launcher = document.getElementById('chat-launcher');
        chatWindow.classList.toggle('hidden');
        
        if (!chatWindow.classList.contains('hidden')) {
            document.getElementById('chat-input').focus();
            scrollToBottom();
        }
    }

    function handleKeyPress(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    }

    function scrollToBottom() {
        const messages = document.getElementById('chat-messages');
        messages.scrollTop = messages.scrollHeight;
    }

    async function appendMessage(role, content) {
        const messages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${role}`;
        
        let htmlContent = content;
        if (role === 'assistant' && typeof marked !== 'undefined') {
            if (typeof marked.parseAsync === 'function') {
                htmlContent = await marked.parseAsync(content);
            } else if (typeof marked.parse === 'function') {
                htmlContent = marked.parse(content);
            } else if (typeof marked === 'function') {
                htmlContent = marked(content);
            }
            
            if (typeof DOMPurify !== 'undefined') {
                htmlContent = DOMPurify.sanitize(htmlContent);
            }
        } else if (role === 'user') {
            // 简单的转义防止XSS
            const div = document.createElement('div');
            div.textContent = content;
            htmlContent = div.innerHTML.replace(/\n/g, '<br>');
        }
        
        messageDiv.innerHTML = `<div class="message-content">${htmlContent}</div>`;
        messages.appendChild(messageDiv);
        scrollToBottom();
        
        // 更新历史记录
        chatHistory.push({ role, content });
        if (chatHistory.length > MAX_HISTORY) {
            chatHistory = chatHistory.slice(-MAX_HISTORY);
        }
    }

    async function sendMessage() {
        const input = document.getElementById('chat-input');
        const message = input.value.trim();
        const sendBtn = document.getElementById('send-btn');
        
        if (!message) return;
        
        // 禁用输入
        input.value = '';
        input.disabled = true;
        sendBtn.disabled = true;
        
        // 显示用户消息
        await appendMessage('user', message);
        
        // 添加Loading状态
        const messages = document.getElementById('chat-messages');
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'chat-loading';
        loadingDiv.className = 'message assistant';
        loadingDiv.innerHTML = '<div class="message-content"><div class="typing-indicator"><span></span><span></span><span></span></div></div>';
        messages.appendChild(loadingDiv);
        scrollToBottom();
        
        try {
            const apiBase = "{{ with site.Params.chatApiBase }}{{ . }}{{ end }}";
            const endpoint = (apiBase && apiBase !== "") ? `${apiBase}/api/chat` : "/api/chat";
            
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: message,
                    history: chatHistory.slice(0, -1) // 不包含刚才发送的最新消息
                })
            });

            // 移除Loading
            loadingDiv.remove();

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                await appendMessage('assistant', errorData.error || '抱歉，服务暂不可用。');
                return;
            }

            // 处理流式响应
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let aiMessageDiv = null;
            let fullText = "";

            // 获取引用信息 (从Header中)
            const referencesHeader = response.headers.get("X-RAG-References");
            let references = [];
            if (referencesHeader) {
                try {
                    references = JSON.parse(referencesHeader);
                } catch (e) {
                    console.error("Failed to parse references:", e);
                }
            }

            // 创建消息容器
            aiMessageDiv = document.createElement('div');
            aiMessageDiv.className = 'message assistant';
            aiMessageDiv.innerHTML = '<div class="message-content"></div>'; // 初始为空
            document.getElementById('chat-messages').appendChild(aiMessageDiv);
            const contentDiv = aiMessageDiv.querySelector('.message-content');

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value, { stream: true });
                // Cloudflare Workers AI 流式格式: "data: {"response":"..."}\n\n"
                const lines = chunk.split('\n');
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const jsonStr = line.slice(6);
                            if (jsonStr.trim() === '[DONE]') continue;
                            const data = JSON.parse(jsonStr);
                            if (data.response) {
                                fullText += data.response;
                                // 实时渲染 Markdown (简单处理: 累积文本后渲染，或打字机效果)
                                // 为性能考虑，可以每隔一定字符数渲染一次，这里简单全量渲染
                                if (typeof marked !== 'undefined') {
                                    contentDiv.innerHTML = marked.parse(fullText);
                                } else {
                                    contentDiv.textContent = fullText;
                                }
                                scrollToBottom();
                            }
                        } catch (e) {
                            // 忽略解析错误 (可能是分片截断)
                        }
                    }
                }
            }
            
            // 最终渲染并附加引用
            if (fullText) {
                let finalHtml = typeof marked !== 'undefined' ? marked.parse(fullText) : fullText;
                if (references.length > 0) {
                    finalHtml += '<div class="chat-references"><h5>参考来源:</h5><ul>';
                    references.forEach((ref, idx) => {
                        finalHtml += `<li><a href="${ref.url}" target="_blank">[${idx + 1}] ${ref.title}</a></li>`;
                    });
                    finalHtml += '</ul></div>';
                }
                contentDiv.innerHTML = finalHtml;
                
                // 更新历史
                chatHistory.push({ role: 'assistant', content: fullText });
                if (chatHistory.length > MAX_HISTORY) chatHistory = chatHistory.slice(-MAX_HISTORY);
            } else {
                // 如果没有流式内容（例如 "没有找到相关内容" 的JSON响应），尝试按普通JSON解析
                // 注意：如果Header是text/event-stream，但Body是普通JSON，上面的流式读取可能已经消耗了Body
                // 这里的逻辑主要处理异常情况。实际上如果chat.js返回了流，fullText应该有值。
                if (fullText === "") {
                     contentDiv.innerHTML = "没有找到相关内容";
                }
            }

        } catch (error) {
            loadingDiv.remove();
            console.error('Chat error:', error);
            await appendMessage('assistant', "抱歉，网络连接出现问题，请稍后再试。");
        } finally {
            input.disabled = false;
            sendBtn.disabled = false;
            input.focus();
        }
    }
    
    // 自动调整输入框高度
    const textarea = document.getElementById('chat-input');
    textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        const minHeight = 40;
        const newHeight = Math.max(this.scrollHeight, minHeight);
        this.style.height = newHeight + 'px';
    });
</script>
