<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="一个关注 AI 各领域的专题博客"><meta property="og:title" content="Python 的 orjson 库 - My AI Blog"><meta property="og:description" content="一个关注 AI 各领域的专题博客"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Python 的 orjson 库 - My AI Blog"><meta name=twitter:description content="一个关注 AI 各领域的专题博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Python 的 orjson 库","description":"一个关注 AI 各领域的专题博客","author":{"@type":"Person","name":"Your Name"},"datePublished":"2025-04-22T10:34:00\u002b08:00"}</script><title>Python 的 orjson 库 - My AI Blog</title><link rel=stylesheet href=/css/main.css></head><body><div class=site-container><aside class=sidebar><div class=back-home><a href=/ class=back-link><span class=back-arrow>←</span>
<span>返回主页</span></a></div><div class=toc-container><h3 class=toc-title>目录</h3><div class=toc-content><nav id=TableOfContents><ul><li><a href=#底层实现语言-rust><strong>底层实现语言 (Rust)</strong></a></li><li><a href=#优化的序列化和反序列化算法><strong>优化的序列化和反序列化算法</strong></a></li><li><a href=#原生支持更多数据类型><strong>原生支持更多数据类型</strong></a></li><li><a href=#严格遵循-json-规范-rfc-8259><strong>严格遵循 JSON 规范 (RFC 8259)</strong></a></li><li><a href=#专注于性能和正确性><strong>专注于性能和正确性</strong></a></li><li><a href=#总结><strong>总结</strong></a></li><li><a href=#如何使用-orjson>如何使用 <code>orjson</code>？</a></li></ul></nav></div></div></aside><main class=main-content><article class=article-container><header class=article-header><h1 class=article-title>Python 的 orjson 库</h1><div class=article-meta><time class=article-date>2025-04-22</time><div class=article-tags><span class=tag>#Python</span>
<span class=tag>#orjson</span></div></div></header><div class=article-content><p>我们来详细探讨一下 <code>orjson</code> 库以及为什么它通常比 Python 标准库中的 <code>json</code> 模块性能更好。</p><p>首先，需要澄清一点：<strong><code>orjson</code> 并不是 Python 3.11 或任何 Python 版本的标准库组成部分。</strong> 它是一个非常流行的、高性能的第三方 Python 库，需要单独安装（通常通过 <code>pip install orjson</code>）。Python 标准库中用于处理 JSON 的模块仍然是 <code>json</code>。</p><p>尽管如此，<code>orjson</code> 因其出色的性能而广受青睐，尤其是在需要高速处理大量 JSON 数据的场景中。它之所以更快，主要得益于以下几个关键因素：</p><h2 id=底层实现语言-rust><strong>底层实现语言 (Rust)</strong></h2><ul><li><code>orjson</code> 的核心部分是使用 <strong>Rust</strong> 语言编写的。Rust 是一种现代的、内存安全的系统编程语言，以其接近 C/C++ 的高性能而闻名。</li><li>相比之下，Python 标准库的 <code>json</code> 模块主要是用 Python 编写的，虽然它也包含一个 C 语言编写的加速器 (<code>_json</code>)，但在许多操作上，专门为性能优化的 Rust 代码通常能实现更高的执行效率。Rust 的编译时优化、对内存布局的精细控制以及避免 Python 解释器开销的能力，都对性能提升有显著贡献。</li></ul><h2 id=优化的序列化和反序列化算法><strong>优化的序列化和反序列化算法</strong></h2><ul><li><code>orjson</code> 在将 Python 对象序列化为 JSON 字符串 (<code>dumps</code>) 和将 JSON 字符串反序列化为 Python 对象 (<code>loads</code>) 的过程中，采用了高度优化的算法。</li><li>它可能利用了更快的字符串处理技术、更高效的内存管理策略，并可能针对现代 CPU 架构（如 SIMD 指令）进行了优化，以加速解析和生成过程。</li></ul><h2 id=原生支持更多数据类型><strong>原生支持更多数据类型</strong></h2><ul><li>标准 <code>json</code> 库仅原生支持基本的 Python 类型（如 <code>dict</code>, <code>list</code>, <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>None</code>）。对于其他类型（如 <code>datetime</code>, <code>uuid</code>, <code>bytes</code>, <code>dataclasses</code>, <code>enums</code> 等），你需要提供自定义的 <code>default</code> 函数（用于序列化）或 <code>object_hook</code>（用于反序列化）。这些自定义函数的调用会增加额外的开销。</li><li><code>orjson</code> <strong>内置了对多种常用但非 JSON 原生支持的 Python 类型的快速序列化支持</strong>，包括 <code>datetime.datetime</code>, <code>uuid.UUID</code>, <code>int</code> (任意大小), <code>float</code> (包括 <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>), <code>str</code> (正确处理 UTF-8), <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code>, <code>dataclasses</code>, <code>enums</code>, <code>decimal.Decimal</code> 等。这种原生支持避免了 Python 层面的回调开销，直接在 Rust 代码中高效处理，从而显著提高了涉及这些类型的 JSON 操作速度。</li></ul><h2 id=严格遵循-json-规范-rfc-8259><strong>严格遵循 JSON 规范 (RFC 8259)</strong></h2><ul><li><code>orjson</code> 严格遵守 JSON 规范。这意味着它在解析时可能比标准库更严格，不会接受一些格式略有问题的 JSON。虽然这在某些情况下可能需要你确保输入是完全标准的 JSON，但这种严格性也意味着它可以进行更直接、更少分支判断的解析，有助于提高速度。</li><li>它保证输出的 JSON 是符合 RFC 8259 规范的有效 UTF-8 编码字符串。</li></ul><h2 id=专注于性能和正确性><strong>专注于性能和正确性</strong></h2><ul><li><code>orjson</code> 的设计目标就是提供一个既正确又快速的 JSON 库。它在实现上可能做出了一些有利于性能的权衡（例如，可能不如标准库那样灵活地处理某些边缘情况或非标准格式），并将性能优化置于非常高的优先级。</li></ul><h2 id=总结><strong>总结</strong></h2><p>总的来说，<code>orjson</code> 的高性能主要来源于：</p><ul><li><strong>使用 Rust 编写核心逻辑</strong>，利用了编译语言的性能优势和内存效率。</li><li><strong>采用高度优化的序列化/反序列化算法</strong>。</li><li><strong>内置对多种 Python 类型的原生快速支持</strong>，减少了 Python 回调开销。</li><li><strong>严格遵循 JSON 规范</strong>，可能带来更直接高效的实现路径。</li></ul><p>因此，如果你的应用对 JSON 处理的性能有较高要求（例如，Web 框架的请求/响应处理、数据处理管道、API 交互等），使用 <code>orjson</code> 替换标准 <code>json</code> 库通常能带来显著的速度提升。</p><h2 id=如何使用-orjson>如何使用 <code>orjson</code>？</h2><ol><li><p><strong>安装</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install orjson
</span></span></code></pre></div></li><li><p><strong>使用</strong>:
它的 API 设计与标准 <code>json</code> 库非常相似，通常可以轻松替换：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> orjson
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> datetime
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> uuid
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> dataclasses <span style=color:#f92672>import</span> dataclass
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>:
</span></span><span style=display:flex><span>    id: int
</span></span><span style=display:flex><span>    name: str
</span></span><span style=display:flex><span>    registered_at: datetime<span style=color:#f92672>.</span>datetime
</span></span><span style=display:flex><span>    api_key: uuid<span style=color:#f92672>.</span>UUID
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>user <span style=color:#f92672>=</span> User(
</span></span><span style=display:flex><span>    id<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Alice&#34;</span>,
</span></span><span style=display:flex><span>    registered_at<span style=color:#f92672>=</span>datetime<span style=color:#f92672>.</span>datetime<span style=color:#f92672>.</span>now(datetime<span style=color:#f92672>.</span>timezone<span style=color:#f92672>.</span>utc),
</span></span><span style=display:flex><span>    api_key<span style=color:#f92672>=</span>uuid<span style=color:#f92672>.</span>uuid4()
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 序列化 (dumps)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 注意：orjson.dumps 返回的是 bytes，而不是 str</span>
</span></span><span style=display:flex><span>json_bytes <span style=color:#f92672>=</span> orjson<span style=color:#f92672>.</span>dumps(user, option<span style=color:#f92672>=</span>orjson<span style=color:#f92672>.</span>OPT_NAIVE_UTC <span style=color:#f92672>|</span> orjson<span style=color:#f92672>.</span>OPT_PASSTHROUGH_DATACLASS <span style=color:#f92672>|</span> orjson<span style=color:#f92672>.</span>OPT_SERIALIZE_UUID)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Serialized (bytes): </span><span style=color:#e6db74>{</span>json_bytes<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 如果需要字符串，可以解码</span>
</span></span><span style=display:flex><span>json_string <span style=color:#f92672>=</span> json_bytes<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Serialized (string): </span><span style=color:#e6db74>{</span>json_string<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 反序列化 (loads)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># orjson.loads 可以接受 bytes 或 str</span>
</span></span><span style=display:flex><span>data_from_bytes <span style=color:#f92672>=</span> orjson<span style=color:#f92672>.</span>loads(json_bytes)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Deserialized from bytes: </span><span style=color:#e6db74>{</span>data_from_bytes<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>data_from_string <span style=color:#f92672>=</span> orjson<span style=color:#f92672>.</span>loads(json_string)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Deserialized from string: </span><span style=color:#e6db74>{</span>data_from_string<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># orjson 也能处理标准类型</span>
</span></span><span style=display:flex><span>basic_data <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;value&#34;</span>, <span style=color:#e6db74>&#34;number&#34;</span>: <span style=color:#ae81ff>123</span>, <span style=color:#e6db74>&#34;items&#34;</span>: [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>None</span>]}
</span></span><span style=display:flex><span>basic_json_bytes <span style=color:#f92672>=</span> orjson<span style=color:#f92672>.</span>dumps(basic_data)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Basic data serialized: </span><span style=color:#e6db74>{</span>basic_json_bytes<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>basic_deserialized <span style=color:#f92672>=</span> orjson<span style=color:#f92672>.</span>loads(basic_json_bytes)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Basic data deserialized: </span><span style=color:#e6db74>{</span>basic_deserialized<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p><em>注意：<code>orjson.dumps()</code> 默认返回 <code>bytes</code> 对象，这通常更高效，因为避免了最终的 UTF-8 编码步骤。如果需要 <code>str</code>，需要自行解码 (<code>.decode('utf-8')</code>)。另外，对于 <code>datetime</code>、<code>dataclass</code>、<code>uuid</code> 等类型的序列化，可能需要通过 <code>option</code> 参数启用相应的选项。</em></p></li></ol><p>这个详细的解释可以帮助理解 <code>orjson</code> 的高性能来源！</p></div><footer class=article-footer><div class=article-navigation><a href=/technologies/python3/ class="nav-link next"><span class=nav-title>Python 3.x 高级语法与语言特性深度剖析</span>
<span class=nav-arrow>→</span></a></div></footer></article></main></div><style>:root{--primary:#2196f3;--primary-dark:#1a237e;--secondary:#64b5f6;--theme:#121212;--entry:#1e1e1e;--border:#2d2d2d;--code-bg:#2d2d2d;--text:#e0e0e0;--text-secondary:#b0b0b0}.article-content table{width:100%;border-collapse:collapse;margin:1.5rem 0;background:var(--entry);border-radius:8px;overflow:hidden;box-shadow:0 2px 4px rgba(0,0,0,.1)}.article-content th,.article-content td{padding:.8rem;text-align:left;border:1px solid var(--border)}.article-content th{background:var(--primary-dark);color:var(--text);font-weight:600}.article-content tr:nth-child(even){background:var(--code-bg)}.article-content tr:hover{background:rgba(33,150,243,.1)}.site-container{display:flex;gap:2rem;max-width:1200px;margin:0 auto;padding:1.5rem}.sidebar{flex:0 0 250px;position:sticky;top:1.5rem;height:fit-content}.back-home{margin-bottom:1.5rem}.back-link{display:flex;align-items:center;gap:.5rem;color:var(--text-secondary);text-decoration:none;padding:.5rem;border-radius:6px;transition:all .3s}.back-link:hover{background:var(--code-bg);color:var(--primary)}.back-arrow{font-size:1.2rem}.toc-container{background:var(--entry);border-radius:12px;padding:1.2rem;border:1px solid var(--border);box-shadow:0 4px 6px rgba(0,0,0,.3)}.toc-title{color:var(--primary);margin:0 0 1rem;font-size:1.1rem}.toc-content{font-size:.9rem;line-height:1.6}.toc-content ul{list-style:none;padding-left:.5rem;margin:0}.toc-content li{margin:.3rem 0}.toc-content a{color:var(--text-secondary);text-decoration:none;transition:all .3s;display:block;padding:.2rem .5rem;border-radius:4px}.toc-content a:hover{color:var(--primary);background:var(--code-bg)}.main-content{flex:1;min-width:0}.article-container{background:var(--entry);border-radius:12px;padding:2rem;box-shadow:0 2px 4px rgba(0,0,0,.1)}.article-header{margin-bottom:2rem;padding-bottom:1rem;border-bottom:1px solid var(--border)}.article-title{font-size:2rem;color:var(--primary);margin-bottom:1rem;line-height:1.3}.article-meta{display:flex;flex-wrap:wrap;gap:1rem;align-items:center;color:var(--text-secondary);font-size:.9rem}.article-date{background:var(--code-bg);padding:.3rem .6rem;border-radius:4px;font-family:monospace}.article-categories{display:flex;gap:.5rem}.article-tags{display:flex;gap:.5rem;flex-wrap:wrap}.article-content{color:var(--text);line-height:1.8;font-size:1.1rem}.article-content h2{color:var(--primary);margin:2rem 0 1rem;font-size:1.5rem}.article-content h3{color:var(--primary);margin:1.5rem 0 1rem;font-size:1.3rem}.article-content p{margin:1rem 0}.article-content code{background:var(--code-bg);padding:.2rem .4rem;border-radius:4px;font-family:monospace;font-size:.9em}.article-content pre{background:var(--code-bg);padding:1rem;border-radius:8px;overflow-x:auto;margin:1.5rem 0}.article-content blockquote{border-left:4px solid var(--primary);padding-left:1rem;margin:1.5rem 0;color:var(--text-secondary)}.article-content img{max-width:100%;height:auto;border-radius:8px;margin:1.5rem 0}.article-footer{margin-top:3rem;padding-top:2rem;border-top:1px solid var(--border)}.article-navigation{display:flex;justify-content:space-between;gap:1rem}.nav-link{display:flex;align-items:center;gap:.5rem;color:var(--text-secondary);text-decoration:none;padding:.5rem 1rem;border-radius:6px;transition:all .3s;max-width:45%}.nav-link:hover{background:var(--code-bg);color:var(--primary)}.nav-arrow{font-size:1.2rem}.nav-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}@media(max-width:768px){.site-container{flex-direction:column;padding:1rem}.sidebar{position:static;width:100%;max-height:none}.article-container{padding:1.5rem}.article-title{font-size:1.5rem}.article-meta{flex-direction:column;align-items:flex-start}.article-navigation{flex-direction:column}.nav-link{max-width:100%}}</style><footer><p>&copy; 2025 My AI Blog. All rights reserved.</p><p><a href=https://github.com/hobbytp/hobbytp.github.io target=_blank>GitHub</a> |
<a href=https://github.com/hobbytp/hobbytp.github.io/issues target=_blank>反馈</a></p></footer><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll("pre > code.language-mermaid").forEach(function(e){const n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.parentElement.replaceChild(t,n)}),window.mermaid&&mermaid.init()})</script></body></html>