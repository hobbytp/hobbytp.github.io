<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="一个关注 AI 各领域的专题博客"><meta property="og:title" content="Simple Test-Time Scaling 论文解读 - My AI Blog"><meta property="og:description" content="一个关注 AI 各领域的专题博客"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Simple Test-Time Scaling 论文解读 - My AI Blog"><meta name=twitter:description content="一个关注 AI 各领域的专题博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Simple Test-Time Scaling 论文解读","description":"一个关注 AI 各领域的专题博客","author":{"@type":"Person","name":"Your Name"},"datePublished":"2025-02-10T21:36:00\u002b08:00"}</script><title>Simple Test-Time Scaling 论文解读 - My AI Blog</title><link rel=stylesheet href=/css/main.css></head><body><div class=site-container><aside class=sidebar><div class=back-home><a href=/ class=back-link><span class=back-arrow>←</span>
<span>返回主页</span></a></div><div class=toc-container><h3 class=toc-title>目录</h3><div class=toc-content><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#全文摘要>全文摘要</a></li><li><a href=#论文速读>论文速读</a><ul><li><a href=#论文方法>论文方法</a></li><li><a href=#论文实验>论文实验</a></li></ul></li><li><a href=#论文的亮点是>论文的亮点是</a></li><li><a href=#对业界的影响>对业界的影响</a></li><li><a href=#qa>QA</a><ul><li><a href=#为什么只进行1000样本的监督微调可以实现如此高的性能提升>为什么只进行1,000样本的监督微调可以实现如此高的性能提升？</a></li><li><a href=#详细解释什么是预算强制技术>详细解释什么是"预算强制技术"？</a></li><li><a href=#s1-32b模型是如何进行测试时间的控制的>s1-32B模型是如何进行测试时间的控制的？</a></li><li><a href=#该论文对将来推理模型的训练的启发是什么>该论文对将来推理模型的训练的启发是什么？</a></li></ul></li></ul></nav></div></div></aside><main class=main-content><article class=article-container><header class=article-header><h1 class=article-title>Simple Test-Time Scaling 论文解读</h1><div class=article-meta><time class=article-date>2025-02-10</time><div class=article-categories><span class=category>papers</span>
<span class=category>training</span>
<span class=category>opensource</span></div><div class=article-tags><span class=tag>#opensource</span>
<span class=tag>#reasoning</span>
<span class=tag>#SFT</span>
<span class=tag>#论文</span>
<span class=tag>#Finetuning</span></div></div></header><div class=article-content><h2 id=引言>引言</h2><p>Paper: <a href=https://arxiv.org/html/2501.19393v2>https://arxiv.org/html/2501.19393v2</a><br>Github: <a href=https://arxiv.org/html/2501.19393v2>https://arxiv.org/html/2501.19393v2</a></p><p>测试时缩放是一种用于语言建模的有前景的新方法，它利用额外的测试时计算资源来提升性能。最近，OpenAI的o1模型展现了这种能力，但没有公开其方法，这导致了许多复制工作。我们寻求实现测试时缩放和强大推理性能的最简单方法。
1.首先，我们精心整理了一个包含1000个问题及其推理轨迹的小型数据集s1K，这些问题依据我们在消融实验中验证的三个标准（难度、多样性和质量）进行挑选。
2.其次，我们开发了预算强制机制来控制测试时计算资源。具体而言，当模型试图结束思考过程时，我们会强制终止其思考过程，或者通过在模型的生成内容后多次添加"等待"来延长思考时间。这能够促使模型复查自己的答案，常常修正不正确的推理步骤。
3.在对Qwen2.5 - 32B - Instruct语言模型使用s1K数据进行监督微调并为其配备预算强制机制之后，我们的s1 - 32B模型在竞赛数学问题（如MATH和AIME24）上比o1 - preview模型的表现高出多达27%。此外，通过预算强制机制对s1 - 32B进行扩展，能够在无测试时干预的情况下超越其原有性能：在AIME24上的表现从50%提升到57%。
4.我们的模型、数据和代码开源于<a href=https://github.com/simplescaling/s1%E3%80%82>https://github.com/simplescaling/s1。</a></p><h2 id=全文摘要>全文摘要</h2><p>一句话总结： 号称使用50美元微调Qwen2.5 - 32B - Instruct成类似Deepseek R1的推理性模型，来自李飞飞团队。</p><p>这篇论文介绍了一种新的语言模型——test-time scaling，并通过实验验证了其在数学问题上的优越性能。该方法使用额外的测试时间计算来提高模型的表现，同时控制计算预算以避免过拟合。作者们还开发了一个小型数据集和预算强制技术，用于训练模型并优化其表现。最终结果表明，这种方法可以在不进行干预的情况下提高模型的性能，并且可以应用于其他领域的问题解决。</p><h2 id=论文速读>论文速读</h2><h3 id=论文方法>论文方法</h3><h4 id=方法描述>方法描述</h4><p>该论文提出了两种分类测试时间缩放方法：序列化和并行化。其中，序列化方法是指后续计算依赖于早期计算（例如长推理链），而并行化方法是指计算独立运行（例如多数投票）。本文主要关注序列化方法，并提出新的序列化缩放方法以及如何对其进行评估。</p><h4 id=方法改进>方法改进</h4><p>该论文提出的改进方法是预算强制（budget forcing）。它是一种简单且直观的解码时间干预方式，在测试时间强制模型产生最大或最小数量的思考标记以控制模型在思考阶段的输出量。通过将"End-of-Thinking"标记添加到早期退出位置来实现最大限制，并通过抑制"End-of-Thinking"标记的生成来鼓励模型反思当前生成的内容。这种方法可以使模型更好地达到最佳答案。
此外，该论文还提供了基准线方法：条件长度控制和拒绝采样。条件长度控制方法告诉模型在提示中应该生成多长时间，分为三种粒度：基于令牌的控制、基于步数的控制和基于类别的控制。拒绝采样方法则是在给定计算预算的情况下，随机抽样直到生成符合预算的回答为止。</p><h4 id=解决的问题>解决的问题</h4><p>该论文旨在解决测试时间缩放问题，即如何在不牺牲性能的前提下，使模型能够在不同测试时间下自适应地调整其行为。为此，该论文提出了多种方法来衡量测试时间缩放的效果，包括可控性、测试时间缩放斜率和性能等指标。这些方法可以帮助研究人员选择最适合特定任务的缩放方法，并提高模型的性能和效率。</p><h3 id=论文实验>论文实验</h3><p>本文介绍了作者进行的三个对比实验，分别是：
1.模型性能对比实验：该实验比较了不同模型在AIME24、MATH500和GPQA等三个领域的表现，并给出了相应的评估指标和得分。结果表明，作者提出的s1-32B模型是样本效率最高的开放数据推理模型之一，在这三个领域中都表现出色。</p><p>2.数据量、多样性和难度对模型效果的影响实验：该实验通过调整数据集中的数量、多样性和平滑度来测试这些因素对模型效果的影响。结果表明，结合高质量、难度和多样性三个标准的数据集能够提高模型的训练效果。
3.测试时间控制方法对比实验：该实验比较了不同的测试时间控制方法，包括预算强制、步长条件控制、分类条件控制和拒绝采样等。结果表明，预算强制是最有效的测试时间控制方法，可以完美控制、良好扩展并提高模型的表现。
总之，本文通过对多个实验的比较分析，展示了作者提出的s1-32B模型及其相关技术的有效性和优越性。</p><h2 id=论文的亮点是>论文的亮点是</h2><ol><li>找到了1000个高质量的数据和推理轨迹（来自google gemini thinking），可以用它们来SFT一个不错的中小模型成一个类似Deepseek R1的推理模型</li><li>找到了一个通过延迟推理时间来获得更好推理效果的方法。</li></ol><h2 id=对业界的影响>对业界的影响</h2><p>使用相同的S1K数据，应该可以把一些小模型微调成O1/R1这样的DeepThinking模型。</p><h2 id=qa>QA</h2><h3 id=为什么只进行1000样本的监督微调可以实现如此高的性能提升>为什么只进行1,000样本的监督微调可以实现如此高的性能提升？</h3><p>我们假设模型在预训练期间已经接触到了大量的推理数据，这些数据跨越了数万亿个标记。因此，我们的模型已经具备了执行推理的能力。我们的样本高效微调阶段只是激活它，并且我们在测试时间使用预算强制进一步扩展它。这类似于LIMA提出的"表面对齐假设"，其中作者发现1,000个示例就足以使模型遵循用户偏好。</p><h3 id=详细解释什么是预算强制技术>详细解释什么是"预算强制技术"？</h3><p>预算强制技术是一种用于控制模型思考持续时间的技术。它通过在生成过程中强行终止模型的思考过程或者通过多次添加"等待"语句来延长思考过程来实现。这种技术可以帮助模型进行双倍检查并修复错误的推理步骤，从而提高性能。</p><h3 id=s1-32b模型是如何进行测试时间的控制的>s1-32B模型是如何进行测试时间的控制的？</h3><p>在训练完成后，我们通过测试时间预算强制来控制模型花费的计算量。(I) 如果模型生成的思考标记超过了期望限制，则我们强制添加一个结束思考标记来终止思考过程，并让模型开始生成答案。(II) 如果我们希望模型在某个问题上花费更多的测试时间计算，我们可以抑制结束思考标记的生成，并将"等待"附加到当前推理轨迹中，以鼓励更多探索。</p><h3 id=该论文对将来推理模型的训练的启发是什么>该论文对将来推理模型的训练的启发是什么？</h3><p>这篇论文提供了一种简单而有效的方法来实现测试时间的扩展。这种方法可以用于提高语言模型的性能，并且可以应用于其他类型的推理任务。这个方法的关键是创建一个包含高质量、多样性和难度的推理数据集，并使用测试时间预算强制来控制模型的计算量。这可以帮助模型更好地推理出正确答案并避免错误的推理步骤。这个方法也可以作为未来推理模型训练的一个重要参考点，帮助研究人员设计更有效的训练策略。</p></div><footer class=article-footer><div class=article-navigation><a href=/zh/agi/agi/ class="nav-link prev"><span class=nav-arrow>←</span>
<span class=nav-title></span></a>
<a href=/zh/bytedancing/bytedancing_omnihuman/ class="nav-link next"><span class=nav-title>字节跳动OmniHuman-1 开源项目解读</span>
<span class=nav-arrow>→</span></a></div></footer></article></main></div><style>:root{--primary:#2196f3;--primary-dark:#1a237e;--secondary:#64b5f6;--theme:#121212;--entry:#1e1e1e;--border:#2d2d2d;--code-bg:#2d2d2d;--text:#e0e0e0;--text-secondary:#b0b0b0}.article-content table{width:100%;border-collapse:collapse;margin:1.5rem 0;background:var(--entry);border-radius:8px;overflow:hidden;box-shadow:0 2px 4px rgba(0,0,0,.1)}.article-content th,.article-content td{padding:.8rem;text-align:left;border:1px solid var(--border)}.article-content th{background:var(--primary-dark);color:var(--text);font-weight:600}.article-content tr:nth-child(even){background:var(--code-bg)}.article-content tr:hover{background:rgba(33,150,243,.1)}.site-container{display:flex;gap:2rem;max-width:1200px;margin:0 auto;padding:1.5rem}.sidebar{flex:0 0 250px;position:sticky;top:1.5rem;height:fit-content}.back-home{margin-bottom:1.5rem}.back-link{display:flex;align-items:center;gap:.5rem;color:var(--text-secondary);text-decoration:none;padding:.5rem;border-radius:6px;transition:all .3s}.back-link:hover{background:var(--code-bg);color:var(--primary)}.back-arrow{font-size:1.2rem}.toc-container{background:var(--entry);border-radius:12px;padding:1.2rem;border:1px solid var(--border);box-shadow:0 4px 6px rgba(0,0,0,.3)}.toc-title{color:var(--primary);margin:0 0 1rem;font-size:1.1rem}.toc-content{font-size:.9rem;line-height:1.6}.toc-content ul{list-style:none;padding-left:.5rem;margin:0}.toc-content li{margin:.3rem 0}.toc-content a{color:var(--text-secondary);text-decoration:none;transition:all .3s;display:block;padding:.2rem .5rem;border-radius:4px}.toc-content a:hover{color:var(--primary);background:var(--code-bg)}.main-content{flex:1;min-width:0}.article-container{background:var(--entry);border-radius:12px;padding:2rem;box-shadow:0 2px 4px rgba(0,0,0,.1)}.article-header{margin-bottom:2rem;padding-bottom:1rem;border-bottom:1px solid var(--border)}.article-title{font-size:2rem;color:var(--primary);margin-bottom:1rem;line-height:1.3}.article-meta{display:flex;flex-wrap:wrap;gap:1rem;align-items:center;color:var(--text-secondary);font-size:.9rem}.article-date{background:var(--code-bg);padding:.3rem .6rem;border-radius:4px;font-family:monospace}.article-categories{display:flex;gap:.5rem}.article-tags{display:flex;gap:.5rem;flex-wrap:wrap}.article-content{color:var(--text);line-height:1.8;font-size:1.1rem}.article-content h2{color:var(--primary);margin:2rem 0 1rem;font-size:1.5rem}.article-content h3{color:var(--primary);margin:1.5rem 0 1rem;font-size:1.3rem}.article-content p{margin:1rem 0}.article-content code{background:var(--code-bg);padding:.2rem .4rem;border-radius:4px;font-family:monospace;font-size:.9em}.article-content pre{background:var(--code-bg);padding:1rem;border-radius:8px;overflow-x:auto;margin:1.5rem 0}.article-content blockquote{border-left:4px solid var(--primary);padding-left:1rem;margin:1.5rem 0;color:var(--text-secondary)}.article-content img{max-width:100%;height:auto;border-radius:8px;margin:1.5rem 0}.article-footer{margin-top:3rem;padding-top:2rem;border-top:1px solid var(--border)}.article-navigation{display:flex;justify-content:space-between;gap:1rem}.nav-link{display:flex;align-items:center;gap:.5rem;color:var(--text-secondary);text-decoration:none;padding:.5rem 1rem;border-radius:6px;transition:all .3s;max-width:45%}.nav-link:hover{background:var(--code-bg);color:var(--primary)}.nav-arrow{font-size:1.2rem}.nav-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}@media(max-width:768px){.site-container{flex-direction:column;padding:1rem}.sidebar{position:static;width:100%;max-height:none}.article-container{padding:1.5rem}.article-title{font-size:1.5rem}.article-meta{flex-direction:column;align-items:flex-start}.article-navigation{flex-direction:column}.nav-link{max-width:100%}}</style><footer><p>&copy; 2025 My AI Blog. All rights reserved.</p><p><a href=https://github.com/hobbytp/hobbytp.github.io target=_blank>GitHub</a> |
<a href=https://github.com/hobbytp/hobbytp.github.io/issues target=_blank>反馈</a></p></footer><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll("pre > code.language-mermaid").forEach(function(e){const n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.parentElement.replaceChild(t,n)}),window.mermaid&&mermaid.init()})</script></body></html>