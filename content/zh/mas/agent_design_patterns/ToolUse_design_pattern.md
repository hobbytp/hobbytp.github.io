---
title: Agentic设计模式：Tool Use
date: "2025-11-06T18:10:00+08:00"
draft: false
tags: ["AI", "Tool Use", "设计模式", "design pattern", "agentic"]
categories: ["mas"]
description: "Tool Use模式使智能体能够通过集成外部能力来执行超越其训练数据范围的行动。"
wordCount: 2356
readingTime: 6
---

## Tool Use设计模式

**Tool Use**（工具使用）模式是一种**核心智能体逻辑模式**，它使智能体能够通过集成外部能力来**执行超越其训练数据范围的行动**。通过访问工具，智能体可以调用 API、查询数据库、执行代码、抓取网站或与软件系统交互。工具使用将智能体从静态的知识库转变为**能够与现实世界进行实时交互的活跃系统**。

### Pattern Card

```yaml
Name: Tool Use / Function Calling (工具使用/函数调用)
One-liner: 赋予智能体与外部世界交互的能力，执行其静态知识无法完成的真实动作。
Problem-Solution Fit: 解决 LLM 知识静态且有限，无法自主执行现实操作或获取实时信息的局限性。
Key Value: **将 LLM 的推理能力转化为实际行动能力**，连接数字思维与现实世界。
Complexity: ⭐⭐⭐☆☆
When to Use: 
  - 任务需要**当前信息**、**外部计算**或与外部系统交互的场景。
  - 只要智能体需要突破 LLM 内部知识、与外部世界交互，就应采用此模式。
  - 生产环境中的智能体处理现实任务时，该模式几乎是**不可或缺的**。
When NOT to Use: 
  - 任务可以通过单一查询或 LLM 内部知识直接解决。
  - 工具调用过于频繁，导致延迟和成本过度增加。
```

**比喻：Tool Use 模式**

如果将 LLM 比作一个**拥有百科全书的大脑**，那么 **Tool Use 模式**就是**这颗大脑的四肢和感官**。大脑（LLM）可以推理、计划和思考，但无法亲自去查询实时天气、计算复杂数据或发送邮件。工具（如 API 或代码执行器）为它提供了**标准化、可编排的接口**，使其能够伸出“手”去执行外部动作，并用“眼睛”接收反馈，从而突破了静态知识的限制。

### I. 概述、背景与核心问题（Context & Problem）

1. 核心概念与定义

Tool Use 模式（工具使用）是智能体设计的基础模式之一，它通过**集成外部能力**，使智能体能够执行超出其静态训练数据范围的操作。该模式的核心在于 LLM **编排**这些外部能力，根据任务要求决定调用哪个工具、如何调用，并解释其输出，将多个工具调用链接起来以达成目标。

2. 解决的问题

LLM 尽管是强大的文本生成器，但其知识是静态且有限的，本质上与外部世界隔离。这一限制使其**难以解决需要与外部 API、数据库或服务交互的实际问题**。Tool Use 模式通过提供标准化解决方案，赋予了智能体**行动能力**。

### II. 核心思想、角色与机制（Core Concept & Workflow）

Tool Use 的核心思想是将智能体从静态知识库转变为**具备实时交互能力**的主动系统。

1. **智能体推理**：智能体根据用户请求和当前上下文进行推理，决定是否需要工具、以及哪个工具最合适。
2. **生成结构化请求**：如果需要工具，智能体生成一个**结构化的调用请求**（如 JSON 或函数调用格式），指定要调用的函数名称和参数。
3. **执行与观察**：智能体框架（编排层）实际执行工具调用，并将外部 API 或服务的返回结果作为**观察结果**。
4. **结果综合**：智能体接收工具的输出，并将其**合成**到连贯的响应中，从而将最新外部信息或动作结果整合进来。

### III. 架构蓝图与可视化（Architecture & Visualization）

Tool Use 模式在架构上强调智能体（LLM）作为**决策者**和**编排者**的角色，它指导外部工具的执行。

* **结构元素**：智能体（LLM）、工具注册表/库（Tools）、结构化调用请求（Function Call）、外部系统（External System/API）、观察结果（Observation）。
* **流程流向**：智能体接收输入 → （推理）决定使用工具 → 生成工具调用请求 → 外部系统执行工具 → 观察结果返回给智能体 → 智能体生成最终答案。
* **核心关联**：Tool Use 可以是独立模式，但它通常作为 **ReAct 循环**中“行动”（Action）步骤的具体实现，实现推理与外部交互的协同。

**Tool Use 设计模式 (视觉总结)**

这个模式的视觉总结通常展示了 LLM 如何与多个外部工具（如数据库、Excel、浏览器）进行交互，以此来扩展其能力。

### IV. 优势、价值与设计权衡（Value & Trade-offs）

1. 价值与优势

* **实时交互能力**：使智能体能够获取**实时信息**、执行**精确计算**或触发**实际动作**，突破了静态训练数据的时间限制。
* **功能扩展**：通过集成工具，智能体拥有**可扩展的功能库**，能够与数据库、库存系统等各种外部系统交互。
* **解决现实问题**：Tool Use 是构建能够处理真实世界任务的**实用**智能体的关键。
* **简化 LLM 设计**：通过将复杂逻辑委托给确定性的代码或 API，LLM 可以专注于**推理和协调**。

2. 局限性与设计权衡

* **可靠性耦合**：**工具的可靠性会成为智能体系统的可靠性**。如果外部 API 返回错误、达到限速或超时，智能体将继承这些故障。
* **维护负担**：每一次工具的集成都会带来维护负担，需要随着 API 的变化而更新实现。
* **准确性要求**：需要有效地提示 LLM 生成**正确格式**的工具调用（如函数名和参数），否则会导致解析错误。
* **复杂性管理**：随着工具库的增大，管理工具的可靠性、选择的准确性以及系统复杂性成为挑战。

### V. 适用场景与选择标准（Use Cases & Selection Criteria）

Tool Use 模式是处理现实世界任务的**必要条件**。

* **客户服务**：查询订单数据库和库存系统，处理退款请求。
* **数据分析**：对实时数据集执行统计计算。
* **研究助理**：访问超越训练截止日期的当前信息。
* **自动化操作**：在业务软件平台中触发操作，例如发送短信通知或安排会议。
* **代码执行**：在受控环境中运行代码片段，进行计算和操作。

**选择决策**

当你需要评估智能体能力边界时，Tool Use 是关键的考虑因素：

| 维度 | 决策点 | 推荐模式 |
| :--- | :--- | :--- |
| **知识来源** | **任务需要 LLM 静态知识之外的实时或专有信息吗？** | 是 → **Tool Use** |
| **行动能力** | **任务需要智能体执行实际的外部操作吗？** | 是 → **Tool Use** |
| **任务复杂度** | **如果需要工具，解决任务路径是固定还是动态的？** | 固定 → **顺序执行 + Tool Use**。动态且需透明度 → **ReAct + Tool Use**。 |

### VI. 实现、框架支持与关联模式（Implementation & Relations）

#### 核心实现

实现 Tool Use 的核心是**向 LLM 描述可用工具及其功能**，LLM 通过推理决定何时调用并输出结构化的工具调用请求。

* **LLM 推理**：LLM 必须能够准确理解其可用工具（包括名称、描述、参数要求）的文档，并将其映射到用户请求上。
* **工具适配器（Tool Adapter）**：这是一个模式，负责将智能体的标准化请求翻译成外部工具或 API 所需的具体格式，并处理认证、错误管理和重试。

#### 框架支持

* **LangChain/LangGraph**：提供了 `@tool` 装饰器简化工具定义，并提供 `create_tool_calling_agent` 等方法实现工具调用循环。
* **AutoGen**：通过 `FunctionTool` 包装器实现工具的使用和 ReAct 模式。
* **AutoGPT**：其架构中包含**工具整合与多源交互模式**，能够集成互联网访问、代码执行和 API 调用。
* **Coze**：通过 **Plugin 系统**实现 Tool Use 模式，允许用户添加官方、自定义或商业插件，智能体根据任务自动调用。
* **OpenAI Agents SDK**：要求定义工具（Functions/APIs）并配置指令，使智能体能够根据工作流状态动态选择合适的工具。

#### 关联模式

* **ReAct**：ReAct 模式（推理与行动）将工具使用作为其**核心“行动”步骤**，是工具使用模式的高级、迭代实现。
* **规划（Planning）**：规划模式生成的步骤序列通常包含需要由 Tool Use 完成的具体行动。
* **工具/智能体注册表（Tool/Agent Registry）**：该模式维护一个集中式目录，帮助智能体或编排器有效地**发现和选择**最合适的工具。
* **异常处理与恢复（Error Handling & Recovery）**：当工具失败（如 API 错误）时，该模式提供重试、回退或自我修正策略来确保系统稳健性。
