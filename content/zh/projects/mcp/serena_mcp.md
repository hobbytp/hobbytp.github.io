---
title: 每周一个MCP：Serena MCP
date: "2025-10-21T15:03:00+08:00"
tags: ["mcp", "serena", "coding"]
categories: ["projects"]
draft: false
description: Serena MCP 是一个功能强大且开源的编码代理工具包，旨在将大型语言模型（LLMs）转化为具备完整功能的智能代码助手，专注于语义代码检索和编辑，模拟集成开发环境（IDE）的能力。
---

## 背景

想象一下，你有一位才华横溢的AI编程助手，但它像个“代码盲人”：你只能把代码片段一段段地复制到聊天框里，它无法感知项目的全貌，不知道函数之间的调用关系，修改代码就像在黑暗中摸索。这正是当前大多数AI编程工具的现状。

而 ​Serena MCP​ 的出现，彻底终结了这个时代。它不是一个单独的AI模型，而是一个超级工具包，为你已有的AI（无论是 Claude、GPT 还是本地模型）装上了一个“IDE大脑”，让它从“文本生成器”蜕变为真正的“软件工程师”。与传统编码工具不同，Serena 完全不依赖特定框架，通过提供 **语义代码检索和编辑工具** 弥合了 LLM 与专业开发环境之间的鸿沟，并提供了类似 IDE 的语义代码理解和操作能力，可在符号级别运行。无需依赖读取整个文件、执行 grep 搜索或进行字符串替换等粗糙的文件级操作，Serena 能够实现精确的符号级操作，显著提升效率和代码质量。

## **1、核心奇迹：从“文本理解”到“符号理解”的降维打击**

普通AI工具看待代码就像我们看一篇文章，只能进行文字匹配。而Serena的核心在于利用了 **语言服务器协议（LSP）**——这正是 VS Code、IntelliJ 等现代IDE能够智能跳转定义、查找引用的底层技术。

* **传统AI（无Serena）：** “帮我找到所有调用 `process_data` 的地方。”
  * AI行为：在项目文件中进行全局文本搜索“`process_data`”，结果可能包含变量名、注释、字符串，精准度低，且无法区分定义和引用。
* **智能AI（搭载Serena）：** “帮我找到所有调用 `process_data` 的地方。”
  * AI行为：调用Serena的 `find_referencing_symbols` 工具。Serena通过LSP向语言服务器查询，**毫秒级返回**所有精确调用该函数的位置列表，绝无遗漏或误判。

**这就好比从使用“Ctrl+F”的原始人，进化成了使用“IDE智能导航”的现代开发者，是真正的降维打击。**

## **2、栩栩如生的能力展示：你的AI能做什么？**

搭载Serena后，你的AI助手不再只是一个聊天伙伴，而是能直接在你的项目里“干活”的全能代理。

1. **🧭 IDE级智能导航**
    * **场景：** 接手一个庞大的开源项目，想理清一个核心函数的来龙去脉。
    * **AI指令：** “分析 `src/core/engine.py` 中 `start()` 函数的所有引用关系。”
    * **Serena赋能：** AI会利用Serena的工具，为你生成一张清晰的函数调用关系图，让你瞬间理解代码执行流程。

2. **✍️ 手术刀式精准编辑**
    * **场景：** 需要在一个复杂的类中添加一个新方法。
    * **AI指令：** “在 `UserService` 类中、`get_user` 方法之后，插入一个名为 `reset_password` 的方法。”
    * **Serena赋能：** AI不是重写整个文件，而是像资深开发者使用IDE一样，在符号级别进行**精准插入**，代码格式完美，绝不会破坏现有结构。

3. **🚀 全自动开发工作流**
    * **场景：** “我需要为项目添加用户认证功能，包括登录、注册和密码重置。”
    * **Serena赋能：** 你可以要求AI**制定分步计划**，然后它自己会：
        * 分析现有代码结构，找到合适的切入点和需要修改的文件。
        * 编写新的代码文件（如 `auth.py`）。
        * 在现有代码中插入路由注册、导入语句。
        * **运行测试**，检查新功能是否正常，是否破坏了旧功能。
        * 最后，执行 `git add` 和 `git commit` 提交更改。
    * **结果：** 你提出需求，AI打工。你只需要在关键节点确认，效率提升十倍不止。

## **3、无缝集成：如何将这股“神力”注入你的工作流？**

Serena的另一个强大之处在于其**模型无关性和平台无关性**，通过 **模型上下文协议（MCP）** 实现无缝集成。

| 你的主力工具 | 如何接入Serena（生动比喻） | 体验提升 |
| :--- | :--- | :--- |
| **Claude Code / Claude Desktop** | 在配置文件中添加几行代码，就像给Claude安装了一个“专业编程插件”。 | 让本就强大的Claude如虎添翼，成本更低、效果更好。 |
| **Cursor / Windsurf / VSCode** | 作为MCP服务器接入，相当于为你喜欢的IDE配了一个“内置的AI架构师”。 | 补齐了这些工具在大型项目代码分析上的短板，实现智能重构。 |
| **本地模型（如Qwen, Gemini CLI）** | 通过Agno等框架集成，相当于给免费的“本地AI大脑”连接了一个“IDE视觉皮层”。 | 让本地模型具备处理复杂项目的能力，性价比极高。 |
| **ChatGPT** | 通过 `mcpo` 工具桥接，让ChatGPT也能“看到”并操作你的代码库。 | 扩展了ChatGPT的编程能力边界。 |

**一句话总结：你几乎可以在任何你喜欢的编程环境中，为你选择的任何AI模型，赋予Serena的超能力。**

## **4、最佳实践与高阶玩法：像王牌指挥官一样调度AI**

* **项目记忆：** Serena可以为每个项目创建“记忆文件”（如`项目架构.md`、`数据库设计.md`）。新对话开始时，AI先读取记忆，瞬间进入上下文，无需重复分析。
* **复杂任务分解：**
  * **指令：** “我们接下来要重构支付模块。请先制定一个详细计划，并保存为记忆。”
  * **指令：** “现在执行第一步：分析现有支付流程的依赖关系。”
  * **指令：** “每完成一个步骤，请运行相关测试，确保无误。”
* **安全网：**
  * **指令：** “在开始修改前，请先检查git状态。”
  * **指令：** “如果修改出错，请使用git恢复文件。”

## **5、为什么Serena是游戏规则改变者？**

| 特性 | 传统AI编程工具 | **Serena MCP** |
| :--- | :--- | :--- |
| **代码理解** | 文本级别，模糊 | **符号级别，精准** |
| **项目规模** | 适合小文件、片段 | **擅长大型、复杂项目** |
| **集成方式** | 通常绑定特定平台/模型 | **自由、开源、可插拔** |
| **成本** | 往往需要订阅或支付API费用 | **免费！增强你已有的模型** |

## Serena主要优点如下

1. **多功能性与平台兼容性：**  
   * 可与多种 LLMS（如 Claude Code、Codex、ChatGPT 等）集成，并支持多种客户端工具和集成开发环境（如 VSCode、Cursor、IntelliJ 等）。  
   * 支持多种编程语言，包括 Python、TypeScript、PHP、Java、C/C++、Rust、Go、Ruby、Perl、Dart、Bash等**25种语言**，并可通过语言服务器协议（LSP）轻松扩展支持的语言。  

2. **高效智能代码操作：**  
   * 提供工具如 `find_symbol`、`insert_after_symbol` 和 `replace_symbol_body`，实现类似IDE的高级代码导航和编辑功能。  
   * 通过**符号层级**而非逐行的方式理解代码，尤其适用于大的、结构复杂的代码库。

3. **灵活部署与操作模式：**  
   * 可本地安装、通过 Docker 或 Nix 运行，也可以通过多种方式作为 MCP 服务器使用。支持多种运行模式（例如 Streamable HTTP 模式）。  
   * 提供上下文与模式自定义，满足不同集成与工作流需求。

4. **社区驱动与开源：**  
   * 完全免费，无需订阅或 API 密钥，也没有 API 调用费用。  
   * 可扩展性强，支持工具和功能个性化开发，已广泛获得社区贡献支持。

5. **快速上手与使用体验：**  
   * 提供详细的文档，包括从项目激活、索引到内存保存的完整工作流程。  
   * 提供用于管理日志与工具的直观仪表盘，同时支持多用户设计优化。

Serena 致力于提升LLM驱动的代码助手的效率和功能，尤其适合处理复杂项目，但对于小型项目或从头开始的编码任务，效果可能较弱。如果需要更高生产力或扩展 LLM 能力，Serena 是一个理想选择。

另外：

* SuperClaude内置Serena，所以如果你使用SuperClaude话，就不用单独使用Serena了。
* Serena会在项目根目录下创建".serena"目录，还会在“.serena/memories”中创建一些 md 文件来理解项目，并利用它们更高效地处理流程。之后，- Serena 会使用自己的工具，不是读取全部代码，而是只读取必要的代码。Cursor 已经有索引系统了，但 Claude Code 没有，所以使用 Serena 会极大提升你的 Claude Code 效率。

## 如何助力Coding Agent的Context Engineering？

Claude Code之类的Coding assistant本身已支持本地上下文、代码导航和一些工具调用，但要把“上下文工程”做成体系化、可编排、可复现的工程能力，Serena 通过 MCP 能在四个层面显著放大 coding agent 的效果：**上下文选择、上下文结构化、上下文行动化、上下文记忆化**。
我看到有人说，serena能帮节省多达约**70%**的token！以我的经验来看，serena确实能节省token。

**1、上下文选择：把“找到对的片段”变成确定性流程**

* 符号级召回而非文件级粗检：
  * 使用 find_symbol、find_referencing_symbols、get_symbols_overview 等工具，Claude 可精确定位函数/类/接口及其引用闭包，避免把整文件塞进上下文。
* 语义回退机制：
  * 当 LSP 无法提供直接关系（如跨语言调用、反射/动态注册），Serena 的语义记忆层可按 embedding 相似度补齐候选上下文。
* Token 经济性：
  * 仅把“目标符号 + 最小依赖闭包 + 相关调用点”注入 Claude 的提示，而不是整文件/整模块，降低噪声和成本。

**2、上下文结构化：将“无序片段”变成“可推理的图谱”**

* 统一上下文打包协议：
  * MCP 层将检索结果以结构化单元返回（symbol kind、location、signature、docstring、incoming/outgoing edges），而不是原始文本拼接。
* 关系显式化：
  * 在提示中用关系清单组织上下文，如“此函数被 X 调用，调用了 Y/Z，约束条件为 A/B”，让 Claude 的链式推理路径更短、更稳。
* 设计意图与决策历史并列呈现：
  * 通过内存系统，将该符号的历史 PR 讨论、设计文档摘要、约束警示一并纳入上下文，使 Claude 避免“与历史决策冲突”的建议。

**3、上下文行动化：让“看懂上下文”直接变成“可执行编辑”**

* 可编排的符号级编辑原语：
  * insert_after_symbol、insert_before_symbol、replace_symbol_body 等，让 Claude 在拿到上下文后能生成 WorkspaceEdit 级别的“行动计划”，避免脆弱的字符串替换。
* 影响面预估与验证回路：
  * 先用 find_referencing_symbols 列出受影响点，Claude 生成变更计划；应用后再二次扫描验证是否有漏改，形成“闭环上下文工程”。
* 多步工作流封装：
  * MCP 工具可被 Claude 作为子步骤调用：检索→计划→编辑→编译/测试触发→回溯修正，保证长链条任务的稳定性和可复用性。

**4、上下文记忆化：把一次性的上下文变成团队的“持久知识”**

* 项目级 memory：
  * 将“为何这样改”的 rationale、踩坑记录、边界条件作为条目写回记忆层，后续相似任务自动被召回到 Claude 的上下文里。
* 语义索引联动：
  * 每次成功变更，提炼“模式化策略”（如重命名 API 的标准步骤），下次 Claude 直接复用策略模板，减少推理漂移。
* 客户端无关性：
  * 这些记忆与工具存在 MCP 侧，不绑死在某个 IDE。即使从 Claude Code 切到 Roo Code/CLI/CI Bot，也能复用相同上下文工程资产。

## 实践落地方案（面向 Claude Code 的最小可行集）

* 提示模版要点
  * 先取符号概览→补齐引用闭包→注入设计意图与历史限制→让 Claude 输出“编辑计划 JSON”（含受影响文件、变更点、验证步骤）→再调用编辑原语。
* 质量控制
  * 变更前后自动生成影响清单 diff，要求 Claude 对每个差异点给出“原因解释与验证断言”，避免“看起来改对了但语义漂移”。
* Token 管控
  * 约定每轮调用的上下文预算：符号文摘 + 必要片段 + 关键引用点的最小片段；对大函数只注入签名与关键片段锚点，全文按需拉取。

## 快速开始

### 1. 安装

**cursor/copilot**

```json
{
  "mcpServers": {
    "serena": {
      "command": "uvx",
      "args": [
        "--from",
        "git+https://github.com/oraios/serena",
        "serena-mcp-server"
      ]
    }
}

```

**Claude Code**

```bash
claude mcp add serena -- uvx --from git+https://github.com/oraios/serena serena start-mcp-server --context ide-assistant --project $(pwd)
```

### 2. Onboarding

首次使用 Serena 时，您需要运行 **“Serena Onboarding"** 。引导流程是Serena读取并理解项目并为您的编码做准备的过程。引导流程会在**serena\memories**  文件夹中生成  **memories (md files)** 。此引导流程会读取许多文件并消耗大量代币，所以请注意不要耗尽代币。要运行引导流程，您需要让您的 Claude Code（或其他工具）在聊天中启动 Serena 引导流程。另外，在我的情况下，部分记忆并不准确，我需要进行修正。

### 3. Indexing

在初始化过程中还生成了一个缓存文件  .serena\cache\typescript\document_symbols_cache_v23-06-25.pkl 。当我用光标编辑器打开缓存文件时，内容是乱码，但我能看到索引已创建。不过，该索引似乎并未涵盖整个项目。因此，我运行了下面的命令，为整个项目创建了索引。

```bash
uvx --from git+https://github.com/oraios/serena serena project index
```

## 使用示例

>分析这个项目的执行流程

>请运行代码质量检测工具，检查有哪里需要改进的地方。

>请为这个重构任务创建一个详细的计划，并保存为记忆。

>显示所有项目记忆

>请实现一个完整的用户管理系统

```bash
我需要实现一个完整的用户管理系统,包括:
1. 用户注册和登录
2. 密码重置功能
3. 用户资料管理
4. 权限控制
5. 相应的测试
```

## 结论

Serena MCP 不仅仅是一个工具，它代表了一种范式转移——AI从被动的“辅助者”变成了主动的、拥有“视觉”和“动手能力”的“合作者”。如果你正在经历AI编程工具在复杂项目前的无力感，那么Serena就是你一直在等待的答案。
Serena 能够减少token使用量、缩短响应时间，还能提升代码质量。使用 Serena 简单又免费，所以为何不试试看呢。

## 参考

* [Serena MCP Server Github](https://github.com/oraios/serena)
* [Serena MCP Server Documentation](https://github.com/oraios/serena/blob/main/docs/)
* [Serena MCP Server Overview in Zread.ai](https://zread.ai/oraios/serena/1-overview)
